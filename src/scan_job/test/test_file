mod scan_job;
use bytesize::ByteSize;
use clap::Parser;
use crossbeam::channel::unbounded;
use crossbeam::channel::Receiver;
use crossbeam::queue::SegQueue;
use ignore::WalkBuilder;
use rayon::prelude::*;
use std::borrow::Cow;
use std::collections::HashMap;
use std::fs;
use std::fs::DirEntry;
use std::sync::atomic::AtomicBool;
use std::{
    path::PathBuf,
    sync::atomic::{AtomicU64, Ordering},
    sync::{Arc, Mutex},
    thread,
};
use superconsole::style::ContentStyle;
use superconsole::{Lines, SuperConsole};
use walkdir::WalkDir;

fn test1(root: &str) {
    let entries: Vec<_> = WalkDir::new(root)
        .into_iter()
        .filter_map(Result::ok)
        .filter(|entry| entry.file_type().is_file())
        .collect();

    let size = entries
        .par_iter()
        .fold(
            || 0u64,
            |acc, entry| {
                let size = entry.metadata().map(|m| m.len()).unwrap_or(0);
                acc + size
            },
        )
        .reduce(|| 0u64, |a, b| a + b);

    println!("Total size: {} bytes", ByteSize::b(size));
}

fn test2(root: &str) {
    let (s, r) = unbounded::<String>();
    s.send(root.to_string()).unwrap();

    let size = Arc::new(AtomicU64::new(0));

    thread::scope(|scope| {
        let stop_flag = Arc::new(AtomicBool::new(false));
        let ctrl = Arc::new(Mutex::new((r.clone(), 0u32)));
        for _ in 0..num_cpus::get() {
            let s = s.clone();
            let stop_flag = stop_flag.clone();
            let ctrl = ctrl.clone();
            let size = size.clone();
            scope.spawn(move || {
                while !stop_flag.load(Ordering::SeqCst) {
                    let entry_path;
                    {
                        let mut ctrl = ctrl.lock().unwrap();
                        match ctrl.0.try_recv() {
                            Ok(path) => {
                                entry_path = path;
                            }
                            Err(e) => {
                                if e.is_empty() {
                                    continue;
                                } else {
                                    break;
                                }
                            }
                        }

                        ctrl.1 += 1;
                    }

                    match fs::read_dir(entry_path) {
                        Ok(entries) => {
                            for entry in entries.filter_map(Result::ok) {
                                if let Ok(file_type) = entry.file_type() {
                                    let path = entry.path();
                                    if file_type.is_dir() {
                                        s.send(path.to_string_lossy().to_string()).unwrap();
                                    } else {
                                        size.fetch_add(
                                            entry.metadata().map(|m| m.len()).unwrap_or(0),
                                            Ordering::SeqCst,
                                        );
                                    }
                                }
                            }
                        }
                        Err(e) => {
                            println!("Error reading directory: {}", e);
                        }
                    }

                    {
                        let mut ctrl = ctrl.lock().unwrap();
                        ctrl.1 -= 1;

                        if ctrl.1 == 0 && ctrl.0.is_empty() {
                            stop_flag.store(true, Ordering::SeqCst);
                            break;
                        }
                    }
                }
            });
        }
    });

    println!(
        "Total size: {} bytes",
        ByteSize::b(size.load(Ordering::SeqCst))
    );
}

fn test3(root: &str) {
    let (dir_s, dir_r) = unbounded::<String>();
    let size = Arc::new(AtomicU64::new(0));

    dir_s.send(root.to_string()).unwrap();
    thread::scope(|scope| {
        let stop_flag = Arc::new(AtomicBool::new(false));
        let ctrl = Arc::new(Mutex::new((dir_r.clone(), 0u32)));

        for _ in 0..(num_cpus::get_physical() * 2 / 3).max(1) {
            let dir_s = dir_s.clone();
            let stop_flag = stop_flag.clone();
            let ctrl = ctrl.clone();
            let size = size.clone();
            scope.spawn(move || {
                let get_message = |greedy_dir: &mut Option<String>| -> Option<String> {
                    {
                        let mut ctrl = ctrl.lock().unwrap();
                        if let Some(path) = greedy_dir.take() {
                            ctrl.1 += 1;
                            return Some(path);
                        };

                        if let Ok(path) = ctrl.0.try_recv() {
                            ctrl.1 += 1;
                            return Some(path);
                        }
                    }

                    return None;
                };

                let mut greedy_dir: Option<String> = None;
                loop {
                    match get_message(&mut greedy_dir) {
                        Some(path) => {
                            match fs::read_dir(path) {
                                Ok(entries) => {
                                    let entries = entries.filter_map(Result::ok);
                                    let mut files = vec![];
                                    for entry in entries {
                                        if let Ok(file_type) = entry.file_type() {
                                            if file_type.is_dir() {
                                                let entry_path =
                                                    entry.path().to_string_lossy().to_string();
                                                if greedy_dir.is_none() {
                                                    greedy_dir = Some(entry_path);
                                                } else {
                                                    dir_s.send(entry_path).unwrap();
                                                }
                                            } else {
                                                files.push(entry);
                                            }
                                        }
                                    }

                                    files.iter().for_each(|entry| {
                                        size.fetch_add(
                                            entry.metadata().map(|m| m.len()).unwrap_or(0),
                                            Ordering::Release,
                                        );
                                    });
                                }
                                Err(e) => {
                                    println!("Error reading directory: {}", e);
                                }
                            };

                            {
                                let mut ctrl = ctrl.lock().unwrap();
                                ctrl.1 -= 1;

                                if ctrl.1 == 0 && ctrl.0.is_empty() && greedy_dir.is_none() {
                                    stop_flag.store(true, Ordering::SeqCst);
                                    break;
                                }
                            }
                        }
                        None => {
                            if stop_flag.load(Ordering::SeqCst) {
                                break;
                            }
                        }
                    }
                }
            });
        }
    });

    println!(
        "Total size: {} bytes",
        ByteSize::b(size.load(Ordering::Acquire))
    );
}

fn test4(root: &str) {
    struct ProcessMessage {
        path: String,
        my_size: Arc<AtomicU64>,
        cache_ref: Arc<Mutex<HashMap<String, u64>>>,
        parent: Option<Arc<ProcessMessage>>,
    }

    impl ProcessMessage {
        fn new(path: String, size_cache: Arc<Mutex<HashMap<String, u64>>>) -> Self {
            Self {
                path,
                my_size: Arc::new(AtomicU64::new(0)),
                cache_ref: size_cache.clone(),
                parent: None,
            }
        }

        fn with_parent(mut self, parent: Arc<ProcessMessage>) -> Self {
            self.parent = Some(parent);
            self
        }

        fn add_size(&self, size: u64) {
            self.my_size.fetch_add(size, Ordering::Release);

            if let Some(parent) = &self.parent {
                // println!("parent {}", &parent.path);
                parent.my_size.fetch_add(size, Ordering::Release);
            }
        }
    }

    impl Drop for ProcessMessage {
        fn drop(&mut self) {
            let size = self.my_size.load(Ordering::Acquire);
            if size > 1_000_000_000 {
                self.cache_ref
                    .lock()
                    .unwrap()
                    .insert(self.path.clone(), size);
            }
        }
    }

    let size_cache = Arc::new(Mutex::new(HashMap::new()));
    let (dir_s, dir_r) = unbounded::<Arc<ProcessMessage>>();
    let root_msg = Arc::new(ProcessMessage::new(root.to_string(), size_cache.clone()));
    dir_s.send(root_msg.clone()).unwrap();

    thread::scope(|scope| {
        let stop_flag = Arc::new(AtomicBool::new(false));
        let ctrl = Arc::new(Mutex::new((dir_r.clone(), 0u32)));

        for _ in 0..(num_cpus::get_physical() * 2 / 3).max(1) {
            let dir_s = dir_s.clone();
            let stop_flag = stop_flag.clone();
            let ctrl = ctrl.clone();
            let size_cache = size_cache.clone();
            scope.spawn(move || {
                let get_message =
                    |greedy_message: &mut Option<Arc<ProcessMessage>>| -> Option<Arc<ProcessMessage>> {
                        {
                            let mut ctrl = ctrl.lock().unwrap();
                            if let Some(msg) = greedy_message.take() {
                                ctrl.1 += 1;
                                return Some(msg);
                            };

                            if let Ok(msg) = ctrl.0.try_recv() {
                                ctrl.1 += 1;
                                return Some(msg);
                            }
                        }

                        return None;
                    };

                let mut greedy_message: Option<Arc<ProcessMessage>> = None;
                loop {
                    match get_message(&mut greedy_message) {
                        Some(msg) => {
                            match fs::read_dir(&msg.path) {
                                Ok(entries) => {
                                    let entries = entries.filter_map(Result::ok);
                                    let mut files = vec![];
                                    for entry in entries {
                                        if let Ok(file_type) = entry.file_type() {
                                            if file_type.is_dir() {
                                                let child_msg = Arc::new(ProcessMessage::new(
                                                    entry.path().to_string_lossy().to_string(),
                                                    size_cache.clone(),
                                                ).with_parent(msg.clone()));

                                                if greedy_message.is_none() {
                                                    greedy_message = Some(child_msg);
                                                } else {
                                                    dir_s.send(child_msg).unwrap();
                                                }
                                            } else {
                                                files.push(entry);
                                            }
                                        }
                                    }

                                    files.iter().for_each(|entry| {
                                        msg.add_size(
                                            entry.metadata().map(|m| m.len()).unwrap_or(0),
                                        );
                                    });
                                }
                                Err(e) => {
                                    println!("Error reading directory: {}", e);
                                }
                            };

                            {
                                let mut ctrl = ctrl.lock().unwrap();
                                ctrl.1 -= 1;

                                if ctrl.1 == 0 && ctrl.0.is_empty() && greedy_message.is_none() {
                                    stop_flag.store(true, Ordering::Release);
                                    break;
                                }
                            }
                        }
                        None => {
                            if stop_flag.load(Ordering::Acquire) {
                                break;
                            }
                        }
                    }
                }
            });
        }
    });

    let size = root_msg.my_size.load(Ordering::Acquire);
    println!("Total size: {} bytes", ByteSize::b(size));
}

fn main() {
    // let args = scan_job::scan_job_args::ScanJobArgs::parse();
    // scan_job::scan_dir(args);

    // let path = "/Users/dafienko/git/engine-worktrees/master";
    let path = ".";

    let start = std::time::Instant::now();
    test3(path);
    println!("Elapsed time: {:?}\n", start.elapsed());

    let start = std::time::Instant::now();
    test4(path);
    println!("Elapsed time: {:?}\n", start.elapsed());
}
